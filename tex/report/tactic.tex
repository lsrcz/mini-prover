\section{Tactic}
Although proofs can be automatically checked given the system above, it requires user to input the whole
term of the specific type, which is tedious, exhaustive, mostly anti-intuitive.\par
So in this part, we introduced some tactics into the system 
to assist users in better writing the proof. With the help of
tactics, the proof becomes more human-readable and intuitive.\par

\subsection{\it apply}
This tactic applies to any goal. The purpose of this tactic is to extract premises of
current goal.

\subsection*{Usage}
\begin{itemize}
\item $\it apply\ \tt t.$ : $\tt t$ is a term of a type whose conclusion is the goal.
\item $\it apply\ \tt t\ \it in\ \tt H.$ : $\tt t$ is a term of a type whose condition is $\tt H$.
\end{itemize}

\subsection*{Implementation}
The tactic {\it apply} tries to match the current goal against the 
conclusion of the type of term. 
If it succeeds, it returns as many subgoals as 
the number of non-dependent premises of the type of term.\par
Here is an example:
\begin{center}
\begin{minted}{coq}
n : nat
m : nat
o : nat
e : eq nat n m -> eq nat m o -> eq nat n o                  
(* Current Goal *)      
eq nat n o                        

(* $\Downarrow$ apply n $\Downarrow$ *)   

n : nat                                         n : nat                                       
m : nat                                         m : nat                                   
o : nat                                         o : nat                                   
e : eq nat n m -> eq nat m o -> eq nat n o      e : eq nat n m -> eq nat m o -> eq nat n o       
(* SubGoal 1 *)                                 (* SubGoal 2 *)          
eq nat m o                                      e : eq nat n m
\end{minted}
\end{center}
Because \mintinline{coq}|e| has a type of \mintinline{coq}|eq nat n m -> eq nat m o -> eq nat n o| 
and the goal is \mintinline{coq}|eq nat n o|,
<<<<<<< HEAD
when applied with \mintinline{coq}|e|,
the goal equals to the conclusion (inner-most term) of the type of the term.
=======
when applied with \mintinline{coq}|n|,
the goal is convertible to the inner-most part of the type of \mintinline{coq}|e|.
>>>>>>> 8f8ff3f60ce84e8c747ee454d6ccc529ab657bd9
And all of the non-dependent premises of the type of term become subgoals.

The tactic {\it apply $\tt tm$ in $\tt H$} tries to match the hypothesis $\tt H$ against the 
condition of the type of $\tt tm$. 
If it succeeds, the hypothesis $\tt H$ will be replaced by the conclusion of $\tt tm$
\begin{center}
\begin{minted}{coq}
n : nat
m : nat
o : nat
H : eq nat n m 
e : eq nat n m -> eq nat m o -> eq nat n o                  
(* Current Goal *)      
eq nat m o -> eq nat n o                                        

(* $\Downarrow$ apply e in H $\Downarrow$ *)
n : nat                                                                         
m : nat                                                                     
o : nat  
H : eq nat m o -> eq nat n o
e : eq nat n m -> eq nat m o -> eq nat n o
(* SubGoal 1*)                                            
eq nat m o -> eq nat n o                                      
\end{minted}
\end{center}
Because \mintinline{coq}|e| has a type of \mintinline{coq}|eq nat n m -> eq nat m o -> eq nat n o| 
and $\tt H$ is \mintinline{coq}|eq nat n m|,
when applied with \mintinline{coq}|e|,
the $\tt H$ equals to the condition of the type of the term.
And $\tt H$ was replaced by the conclusion of $\tt e$.

\subsection{\it destruct}

When {\it destruct} is applied on a term, this term must be inductive type. Then {\it destruct} will divide current goal
into several classified subgoals based on the constructors of the inductive type. During this process, no induction 
hypothesis is generated by {\it destruct}; the {\it destruct} uses {\tt match} to handle classified discussion.

\subsubsection*{Usage}
\begin{itemize}
\item ${\it destruct}\ \tt t.$ : $\tt t$ is a term of inductive type. 
\end{itemize}

\subsubsection*{Implementation}

This tactic not only divides current goal based on the constructors of the inductive
type, but requires the system to handle several equivalent relations proposed by the constructors as well.\par
Here is an example:
\begin{center}
\begin{minipage}{0.7\textwidth}
\begin{minted}{coq}
n, m : nat                                                      
e : eq nat n m                             n : nat  
f : eq nat m m      (* destruct e => *)    f : eq nat n n    
(* Current Goal *)                         (* Current Goal *)
eq nat m n                                 eq nat n n       
\end{minted}
\end{minipage}
\end{center}
From the constructor \mintinline{coq}|eq_refl : eq T x x| and the type of \mintinline{coq}|e : eq nat n m|,
we have \mintinline{coq}|m = n|, so any occurrence of \mintinline{coq}|m| should be replaced by \mintinline{coq}|n|.\par
If some term depends on the destructed term, we should rewrite it.
\begin{center}
\begin{minted}{coq}
n, m : nat                                 n : nat              n : nat                  
e : eq nat n m                             e0 : eq nat n O      e0 : eq nat n (S m0) 
f : eq nat m m      (* destruct m => *)    f0 : eq nat O O      f0 : eq nat (S m0) (S m0) 
(* Current Goal *)                         (* SubGoal 1 *)      (* SubGoal 2 *)
eq nat m n                                 eq nat O n           eq nat (S m0) n     
\end{minted}
\end{center}
The two cases above are viewed from user's perspective.
On the other hand, in the system we also need to construct the term for back substitution.
\begin{center}
\begin{minipage}{\textwidth}
\begin{minted}{coq}
n, m : nat                                     
e : eq nat (S n) (S m)  
(* Current Goal*)                              
eq nat (S m) (S n)                             

(* $\Downarrow$ destruct (S n) $\Downarrow$ *)   

(* The Proof Object *)
(fun (n:nat)(m:nat)(e:eq nat (S n) (S m)) =>                                                                                
    match (S n) as n0 in nat return (eq nat n0 (S m) -> eq nat (S m) n0) with 
    | O => fun e0 : eq nat O (S m) => (* SubGoal 1*)                          
    | S n0 => fun e0 : eq nat (S n0) (S m) => (* SubGoal 2*)                  
    end e)                                                  
\end{minted}
\end{minipage}
\end{center}
After building the {\it return type}, we can build the branches by applying {\it type of branch}.

\subsection{\it exact}

This tactic checks if the input term is actually of the goal's type. If so, the proof of the current goal is finished and the 
constructed proof object is exactly the input term.

\subsubsection*{Usage}
\begin{itemize}
\item ${\it exact}\ \tt t.$ : $\tt t$ is a term of the goal's type. 
\end{itemize}

\subsubsection*{Implementation}
It's easy to implement. Here is an example:
\begin{center}
\begin{minipage}{0.8\textwidth}
\begin{minted}{coq}
m : nat                                                      
(* Current Goal *)  (* exact (eq_refl nat m) => *)  (* No More Goals *)
eq nat m m                                       
\end{minted}
\end{minipage}
\end{center}

\subsection{\it exists}

This tactic handles the exists qualifier. In our system, $\tt\exists (x:T),P\ x$ is represented by $\tt ex\ T\ P$.

Here is the definition of $\tt ex$.
\begin{center}
\begin{minipage}{0.6\textwidth}
\begin{minted}{coq}
Inductive ex (A:Type) (P:A -> Type) : Type :=
| ex_intro : forall (x:A), P x -> ex A P.    
\end{minted}
\end{minipage}
\end{center}

The proof of $\tt\exists (x:T), P\ x$ needs the user to provide a value $\tt x$
and prove that it satisfies the predicate $\tt P$.

\subsubsection*{Usage}
\begin{itemize}
\item ${\it exists}\ \tt t.$ : If the goal is $\tt ex\ (x:T),P\ t$, and $\tt t$ is a term of type $\tt T$. 
\end{itemize}

\subsubsection*{Implementation}
The tactic automatically generates the subgoal $\tt P\ x$.
\begin{center}
\begin{minipage}{0.7\textwidth}
\begin{minted}{coq}
(* Current Goal *)                                                           
ex nat (fun (n:nat) => eq nat (S (S O)) (plus n n))

(* $\Downarrow$ exists S O $\Downarrow$ *)

(* SubGoal *)
eq nat (S (S O)) (plus (S O) (S O))
\end{minted}
\end{minipage}
\end{center}

The proof object built is
\begin{center}
\begin{minipage}{0.8\textwidth}
\begin{minted}{coq}
ex_intro nat (fun (n:nat) => 
                eq nat (S (S O)) (plus n n)) (S O) (* SubGoal *)
\end{minted}
\end{minipage}
\end{center}

\subsection{\it induction}

This tactic applies to any goal. 
The argument term must be of inductive type and the tactic {\it induction} generates subgoals, 
one for each possible form of term, i.e., one for each constructor of the inductive type.

\subsubsection*{Usage}
\begin{itemize}
\item ${\it induction}\ \tt t.$ : $\tt t$ is a term of some inductive type.
\end{itemize}

\subsubsection*{Implementation}

The tactic generates the predicate by the goal and automatically generates 
the subgoals for every constructor of the inductive type.
The equivalence relations introduced by the constructors are also handled.

If the term is a hypothesis, {\it induction} will find the dependencies, 
and try to move them and replace the subterms to solve the dependencies.
And then erase the original hypothesis.

\begin{center}
\begin{minipage}{0.7\textwidth}
\begin{minted}{coq}
                                                                   
n : nat                                                            
(* Current Goal *)   
eq nat (plus n O) n                       

(* $\Downarrow$ induction n $\Downarrow$ *)

(* SubGoal 1 *)    
eq nat (plus O O) O

n0 : nat                     
e : eq nat (plus n0 O) n0    
(* SubGoal 2 *)              
eq nat (plus (S n0) O) (S n0)
\end{minted}
\end{minipage}
\end{center}

After {\it induction}, all we need to prove is the property holds for \mintinline{coq}|O| and 
for any \mintinline{coq}|n|, if \mintinline{coq}|P n| holds,
then the two subgoals are generated and \mintinline{coq}|n| is replaced by the constructors.

The case above is viewed from user's perspective.
On the other hand, in the system we also need to construct the term for back substitution.
\begin{center}
\begin{minipage}{\textwidth}
\begin{minted}{coq}
n : nat                               
(* Current Goal*)                              
eq nat (plus n O) n                             

(* $\Downarrow$ induction n $\Downarrow$ *)   

(* The Proof Object *)
(fun (n:nat) =>   
    nat_rect (fun (n0:nat) => eq nat (plus n0 O) n0)
    (* SubGoal 1 *)
    (fun (n0:nat) (e:eq nat (plus n0 O) n0) => (* SubGoal 2 *))
    n)                                                      
\end{minted}
\end{minipage}
\end{center}

\subsection{\it intro}

If the current goal is a dependent product $\tt \forall x:T,\ U$, \textit{intro} puts 
$\tt x:T$ in the context, and the new subgoal is $\tt U$.\par
If the current goal is a non-dependent product $\tt \forall \_:T,\ U$, \textit{intro} renames
$\tt \_$ into $\tt s$ not in $\tt T,U$ and context. Then put $\tt s:T$ in the context, 
and the new subgoal becomes $\tt U$.

\subsubsection*{Usage}
\begin{itemize}
\item ${\it intro}\ .$ : introduce the outermost argument of current goal and rename them automatically.
\item ${\it intro}\ a_1\ a_2\ \cdots\ a_n.$ : introduce $n$ outermost arguments of current goal and
try to rename them into $a_1,a_2,\cdots,a_n$.
\end{itemize}

\subsubsection*{Implementation}
Since the context automatically preserves the index, we
can safely move the arguments out into the context without worrying about the index.

If the argument is dependent in either the conclusion or some hypotheses of the goal,
the argument is replaced by the appropriate constructor form in each of the resulting subgoals
and induction hypotheses are added to the local context.

Here is an example:
\begin{center}
\begin{minipage}{\textwidth}
\begin{minted}{coq}
                                                        P : Type
(* Current Goal *)                (* intro P => *)      (* SubGoal *) 
forall (x:Type) (f:False), x                            forall (f:False), P
\end{minted}
\end{minipage}
\end{center}

\subsection{\it intros}

If the current goal is a dependent (or non-dependent) product with $m$ arguments, namely,
$\tt \forall x_1:T_1,\ \forall x_2:T_2,\ \cdots\ \forall x_m:T_m,\ U$ where $\tt U$ is not a product type.
Then \textit{intros} will put these $m$ arguments into the context and rename automatically if necessary.

\subsubsection*{Usage}
\begin{itemize}
\item ${\it intros}.$ : introduce all the argument of current goal and rename them automatically.
\end{itemize}

\subsubsection*{Implementation}
Keep calling {\it intro} until all the goal has no arguments.

\subsection{\it left right}
These tactics apply to a goal that is of the disjunction type. Then we can proof one of the two sides to solve the goal.

\subsubsection*{Usage}
\begin{itemize}
    \item ${\it left}.$
    \item ${\it right}.$
\end{itemize}

\subsubsection*{Implementation}
The disjunction type in our system is defined as follows:
\begin{center}
\begin{minipage}{0.6\textwidth}
\begin{minted}{coq}
Inductive or (A:Type) (B:Type) : Type :=
| or_introl : A -> or A B
| or_intror : B -> or A B. 
\end{minted}
\end{minipage}
\end{center}

The tactic ${\it left}$ builds the proof object with the \mintinline{coq}|or_introl| constructor.
The tactic ${\it right}$ builds the proof object with the \mintinline{coq}|or_intror| constructor.
Here is an example:
\begin{center}
\begin{minipage}{\textwidth}
\begin{minted}{coq}
(* Current Goal *)
or (eq nat O O) (eq nat (S O) (S O))

(* $\Downarrow$ left $\Downarrow$ *)

(* The Proof Object *)
or_introl (eq nat O O) (eq nat (S O) (S O)) (* SubGoal 1 *)
\end{minted}
\end{minipage}
\end{center}

\subsection{\it split}
This tactic applies to a goal that is of the conjunction type. Then we need to proof the both sides to solve the goal.

\subsubsection*{Usage}
\begin{itemize}
\item ${\it split}$.
\end{itemize}

\subsubsection*{Implementation}
The conjunction type in our system is defined as follows:
\begin{center}
\begin{minipage}{0.6\textwidth}
\begin{minted}{coq}
Inductive and (A:Type) (B:Type) : Type :=
| conj : A -> B -> and A B.   
\end{minted}
\end{minipage}
\end{center}

The proof object is built with the \mintinline{coq}|conj| constructor.
Here is an example:
\begin{center}
\begin{minipage}{\textwidth}
\begin{minted}{coq}
(* Current Goal *)
and (eq nat O O) (eq nat (S O) (S O))

(* $\Downarrow$ split $\Downarrow$ *)

(* The Proof Object *)
conj (eq nat O O) (eq nat (S O) (S O)) (* SubGoal 1 *) (* SubGoal 2 *)
\end{minted}
\end{minipage}
\end{center}


\subsection{\it reflexivity}
This tactic applies to a goal that has the form $\tt eq\ T\ t\ u$, it check that $\tt t$ and $\tt u$ 
are convertible and then solves the goal.

\subsubsection*{Usage}
\begin{itemize}
\item ${\it reflexivity}.$
\end{itemize}

\subsubsection*{Implementation}
This tactic simply checks if the terms are convertible and build the proof object with \mintinline{coq}|eq_refl| constructor.

\begin{center}
\begin{minipage}{0.7\textwidth}
\begin{minted}{coq}
n : nat
(* Current Goal *)  
eq nat n (plus O n)   

(* reflexivity *)

(* The Proof Object *)
fun (n:nat) => eq_refl nat n
\end{minted}
\end{minipage}
\end{center}

\subsection{\it rewrite}
This tactic applies to any goal.
The type of term must have the form $\tt eq\ T\ t\ u$.
Then the subterms $\tt t$ in the goal will be rewritten by $\tt u$.

\subsubsection*{Usage}
\begin{itemize}
\item ${\it rewrite\ \tt H}.$ : $\tt H$ should have the form $\tt eq\ T\ t\ u$, 
all the subterms $\tt t$ in the goal will be replaced by $\tt u$.
\item ${\it rewrite\ \texttt{<-}\ \tt H}.$ : $\tt H$ should have the form $\tt eq\ T\ t\ u$, 
    all the subterms $\tt u$ in the goal will be replaced by $\tt t$.
\item ${\it rewrite\ [\texttt{<-}/\texttt{->}]\ \tt H\ \it in\ \tt H1}.$ : 
    $\tt H$ should have the form $\tt eq\ T\ t\ u$, for the {\tt ->} case, all the 
    subterms $\tt t$ in $\tt H1$ will be replaced by $\tt u$.
\end{itemize}

\subsubsection*{Implementation}
This tactic builds the proof object with \mintinline{coq}|eq_rect| or \mintinline{coq}|eq_rect_r|.

\begin{center}
\begin{minipage}{0.7\textwidth}
\begin{minted}{coq}
a : nat                                        a : nat        
b : nat                                        b : nat        
e : eq nat a b                                 e : eq nat a b
(* Current Goal *)     (* rewrite e => *)      (* SubGoal *)
eq nat b a                                     eq nat b b

(* Proof Object *)
fun (a:nat) (b:nat) (e:eq nat a b) =>
  (fun (e0:eq nat b b) =>
    eq_rect_r nat b (fun (n:nat) (e1:eq nat b n) =>
      eq nat b n) e0 a e) (* SubGoal *)
\end{minted}
\end{minipage}
\end{center}

\subsection{\it simpl}
This tactic applies to any goal, it tries to reduce a term to something still readable instead of fully normalizing it. 
It performs a sort of strong normalization with a key difference:
\begin{center}
\begin{minipage}{0.7\textwidth}
it unfold a constant if and only if it leads to a $\iota$-reduction, i.e., reducing a {\tt match} or unfolding a {\tt Fix}.
\end{minipage}
\end{center}


\subsubsection*{Usage}
\begin{itemize}
\item ${\it simpl}.$
\item ${\it simpl\ in}\ \tt H.$ : $\tt H$ is a hypothesis.
\end{itemize}

\subsubsection*{Implementation}

The tactic first applies $\beta\iota$-reduction, then it expands constants and tries to reduce 
further using $\beta\iota$-reduction, but when no $\iota$ rule is applied after unfolding,
$\iota$-reductions are not applied. For instance, trying to use $\it simpl$ on 
\mintinline{coq}|eq nat (plus n O) n| changes nothing.
\begin{center}
\begin{minipage}{0.8\textwidth}
\begin{minted}{coq}
n : nat                                          e : nat
(* Current Goal *)           (* simpl => *)      (* Current Goal *)
eq nat (plus n O) (plus O n)                     eq nat (plus n O) n
\end{minted}
\end{minipage}
\end{center}

The tactic can also be applied to the hypotheses, and the same reduction rules applies.
\begin{center}
\begin{minted}{coq}
n : nat                                                    n : nat                
e : eq nat (plus n O) (plus O n)                           e : eq nat (plus n O) n
(* Current Goal *)                 (* simpl in e => *)     (* Current Goal *)      
eq nat (plus n O) n                                        eq nat (plus n O) n         
\end{minted} 
\end{center}

The tactic would never change the current built proof object and won't modify the proof objects built after it.
It is transparent in the proof tree.

\subsection{\it exact}

This tactic checks if the input term is actually of the goal's type. If so, the proof of the current goal is finished and the 
constructed proof object is exactly the input term.

\subsubsection*{Usage}
\begin{itemize}
\item ${\it exact}\ \tt t.$ : $\tt t$ is a term of the goal's type. 
\end{itemize}

\subsubsection*{Implementation}
It's easy to implement. Here is an example:
\begin{center}
\begin{minipage}{0.8\textwidth}
\begin{minted}{coq}
m : nat                                                      
(* Current Goal *)  (* exact eq_refl nat m => *)  (* No more goals *)
eq nat m m                                       
\end{minted}
\end{minipage}
\end{center}


\subsection{\it symmetry}
This tactic applies to a goal that has the form $\tt eq\ T\ t\ u$ 
and changes it into $\tt eq\ T\ u\ t$.

\subsubsection*{Usage}
\begin{itemize}
\item ${\it symmetry}$.
\end{itemize}

\subsubsection*{Implementation}
This tactic builds the proof object use the pre-defined theorem \mintinline{coq}|eq_sym|, here is an example for the proof object building.
\begin{center}
\begin{minipage}{0.6\textwidth}
\begin{minted}{coq}
m : nat
n : nat
e : eq nat m n                    
(* Current Goal*)                              
eq nat n m                           

(* $\Downarrow$ symmetry $\Downarrow$ *)   

(* The proof object *)
fun (m:nat) (n:nat) (e:eq nat m n) =>   
    eq_sym nat m n (* SubGoal *)                                                
\end{minted}
\end{minipage}
\end{center}


\subsection{\it unfold}
This tactic applies to any goal, the argument should denote a defined constant (i.e., not a hypothesis or a axiom).
The tactic applies the $\delta$ rule to each occurrence of the constant in the current goal and then replaces it with its $\beta\iota$-normal form.

\subsubsection*{Usage}
\begin{itemize}
\item ${\it unfold}\ \tt i.$ : $\tt i$ is an identifier. 
\item ${\it unfold}\ \tt i\ \it in\ \tt H.$ : $\tt i$ is an identifier and $\tt H$ is a hypothesis.
\end{itemize}

\subsubsection*{Implementation}
It finds the occurrences of the constant and applies the $\delta$ rule, the nameless index is automatically preserved.
