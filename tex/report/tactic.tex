\section{Tactic}
Although proofs can be automatically checked given the system above, it requires user to input the whole
term of the specific type, which is tedious, exhaustive, mostly anti-intuitive.\par
So in this part, we introduced some tactics into the system 
to assist users in better writing the proof. With the help of
tactics, the proof becomes more human-readable and intuitive.\par

\subsection{\it Apply}

\subsection{\it Destruct}

When {\it destruct} is applied on a term, this term must be inductive type. Then {\it destruct} will divide current goal
into several classified subgoals based on the constructors of the inductive type. During this process, no induction 
hypothesis is generated by {\it destruct}; the {\it destruct} uses {\tt match} to handle classified discussion.

\subsubsection*{Usage}
\begin{itemize}
\item ${\it destruct}\ \tt t.$ : $\tt t$ is a term of inductive type. 
\end{itemize}

\subsubsection*{Implementation}

This tactic not only divides current goal based on the constructors of the inductive
type, but requires the system to handle several equivalent relations proposed by the constructors as well.\par
Here is an example:
\begin{center}
\begin{minipage}{0.7\textwidth}
\begin{minted}{coq}
n, m : nat                                                      
e : eq nat n m                             n : nat  
f : eq nat m m      (* destruct e => *)    f : eq nat n n    
(* Current Goal *)                         (* Current Goal *)
eq nat m n                                 eq nat n n       
\end{minted}
\end{minipage}
\end{center}
From the constructor \mintinline{coq}|eq_refl : eq T x x| and the type of \mintinline{coq}|e : eq nat n m|,
we have \mintinline{coq}|m = n|, so any occurrence of \mintinline{coq}|m| should be replaced by \mintinline{coq}|n|.\par
If some term depends on the destructed term, we should rewrite it.
\begin{center}
\begin{minted}{coq}
n, m : nat                                 n : nat              n : nat                  
e : eq nat n m                             e0 : eq nat n O      e0 : eq nat n (S m0) 
f : eq nat m m      (* destruct m => *)    f0 : eq nat O O      f0 : eq nat (S m0) (S m0) 
(* Current Goal *)                         (* SubGoal 1 *)      (* SubGoal 2 *)
eq nat m n                                 eq nat O n           eq nat (S m0) n     
\end{minted}
\end{center}
The two cases above are viewed from user's perspective.
On the other hand, in the system we also need to construct the term for back substitution.
\begin{center}
\begin{minipage}{\textwidth}
\begin{minted}{coq}
n, m : nat                                     
e : eq nat (S n) (S m)  
(* Current Goal*)                              
eq nat (S m) (S n)                             

(* $\Downarrow$ destruct (S n) $\Downarrow$ *)   

(fun (n:nat)(m:nat)(e:eq nat (S n) (S m)) =>                                                                                
    match (S n) as n0 in nat return (eq nat n0 (S m) -> eq nat (S m) n0) with 
    | O => fun e0 : eq nat O (S m) => (* SubGoal 1*)                          
    | S n0 => fun e0 : eq nat (S n0) (S m) => (* SubGoal 2*)                  
    end e)                                                                    
\end{minted}
\end{minipage}
\end{center}
After building the {\it return type}, we can build the branches by applying {\it type of branch}.

\subsection{\it Equivalence}

\subsection{\it Exact}

\subsection{\it Exists}

\subsection{\it Induction}

\subsection{\it Intro}

If the current goal is a dependent product $\tt \forall x:T,\ U$, \textit{intro} puts 
$\tt x:T$ in the context, and the new subgoal is $\tt U$.\par
If the current goal is a non-dependent product $\tt \forall \_:T,\ U$, \textit{intro} renames
$\tt \_$ into $\tt s$ not in $\tt T,U$ and context. Then put $\tt s:T$ in the context, 
and the new subgoal becomes $\tt U$.

\subsubsection*{Usage}
\begin{itemize}
\item ${\it intro}\ .$ : introduce the outermost argument of current goal and rename them automatically.
\item ${\it intro}\ a_1\ a_2\ \cdots\ a_n.$ : introduce $n$ outermost arguments of current goal and
try to rename them into $a_1,a_2,\cdots,a_n$.
\end{itemize}

\subsubsection*{Implementation}
Since the context automatically preserves the index, we
can safely move the arguments out into the context without worrying about the index.

\subsection{\it Intros}

If the current goal is a dependent (or non-dependent) product with $m$ arguments, namely,
$\tt \forall x_1:T_1,\ \forall x_2:T_2,\ \cdots\ \forall x_m:T_m,\ U$ where $\tt U$ is not a product type.
Then \textit{intros} will put these $m$ arguments into the context and rename automatically if necessary.

\subsubsection*{Usage}
\begin{itemize}
\item ${\it intros}.$ : introduce all the argument of current goal and rename them automatically.
\end{itemize}

\subsubsection*{Implementation}
Keep calling {\it intro} until all the goal has no arguments.

\subsection{\it Left}

\subsection{\it Reflexivity}

\subsection{\it Rewrite}

\subsection{\it Right}

\subsection{\it Simpl}

\subsection{\it Split}

\subsection{\it Symmetry}

\subsection{\it Unfold}

