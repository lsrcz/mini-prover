\section{Tactic}
Although proofs can be automatically checked given the system above, it requires user to input the whole
term of the specific type, which is tedious, exhaustive, mostly anti-intuitive.\par
So in this part, we introduced some tactics into the system 
to assist users in better writing the proof. With the help of
tactics, the proof becomes more human-readable and intuitive.\par

\subsection{\it Apply}

\subsection{\it Destruct}

When {\it destruct} is applied on a term, this term must be inductive type. Then {\it destruct} will divide current goal
into several classified subgoals based on the constructors of the inductive type. During this process, no induction 
hypothesis is generated by {\it destruct}; the {\it destruct} uses {\tt match} to handle classified discussion.

\subsubsection*{Usage}
\begin{itemize}
\item ${\it destruct}\ \tt t.$ : $\tt t$ is a term of inductive type. 
\end{itemize}

\subsubsection*{Implementation}

This tactic not only divides current goal based on the constructors of the inductive
type, but requires the system to handle several equivalent relations proposed by the constructors as well.\par
Here is an example:
\begin{center}
\begin{minipage}{0.7\textwidth}
\begin{minted}{coq}
n, m : nat                                                      
e : eq nat n m                             n : nat  
f : eq nat m m      (* destruct e => *)    f : eq nat n n    
(* Current Goal *)                         (* Current Goal *)
eq nat m n                                 eq nat n n       
\end{minted}
\end{minipage}
\end{center}
From the constructor \mintinline{coq}|eq_refl : eq T x x| and the type of \mintinline{coq}|e : eq nat n m|,
we have \mintinline{coq}|m = n|, so any occurrence of \mintinline{coq}|m| should be replaced by \mintinline{coq}|n|.\par
If some term depends on the destructed term, we should rewrite it.
\begin{center}
\begin{minted}{coq}
n, m : nat                                 n : nat              n : nat                  
e : eq nat n m                             e0 : eq nat n O      e0 : eq nat n (S m0) 
f : eq nat m m      (* destruct m => *)    f0 : eq nat O O      f0 : eq nat (S m0) (S m0) 
(* Current Goal *)                         (* SubGoal 1 *)      (* SubGoal 2 *)
eq nat m n                                 eq nat O n           eq nat (S m0) n     
\end{minted}
\end{center}
The two cases above are viewed from user's perspective.
On the other hand, in the system we also need to construct the term for back substitution.
\begin{center}
\begin{minipage}{\textwidth}
\begin{minted}{coq}
n, m : nat                                     
e : eq nat (S n) (S m)  
(* Current Goal*)                              
eq nat (S m) (S n)                             

(* $\Downarrow$ destruct (S n) $\Downarrow$ *)   

(fun (n:nat)(m:nat)(e:eq nat (S n) (S m)) =>                                                                                
    match (S n) as n0 in nat return (eq nat n0 (S m) -> eq nat (S m) n0) with 
    | O => fun e0 : eq nat O (S m) => (* SubGoal 1*)                          
    | S n0 => fun e0 : eq nat (S n0) (S m) => (* SubGoal 2*)                  
    end e)                                                                    
\end{minted}
\end{minipage}
\end{center}
After building the {\it return type}, we can build the branches by applying {\it type of branch}.

\subsection{\it Exact}

This tactic checks if the input term is actually of the goal's type. If so, the proof of the current goal is finished and the 
constructed proof object is exactly the input term.

\subsubsection*{Usage}
\begin{itemize}
\item ${\it exact}\ \tt t.$ : $\tt t$ is a term of the goal's type. 
\end{itemize}

\subsubsection*{Implementation}
It's easy to implement.Here is an example.
\begin{center}
\begin{minipage}{0.7\textwidth}
\begin{minted}{coq}
m : nat                                                      
(* Current Goal *)  (* exact eq_refl nat m => *)  (* No more goals *)
eq nat m m                                       
\end{minted}
\end{minipage}
\end{center}

\subsection{\it Exists}

This tactic handles the exists qualifier. In our system, $\exists (x:T),P x$ is represented by $ex T P$.

Here is the definition of $ex$.
\begin{center}
\begin{minipage}{\textwidth}
\begin{minted}{coq}
Inductive ex (A:Type) (P:A -> Type) : Type :=
| ex_intro : forall (x:A), P x -> ex A P.    
\end{minted}
\end{minipage}
\end{center}

The proof of $\exists (x:T), P x$ needs the user provide a value $x$ and proof that it satisfies the predicate $P$.

\subsubsection*{Usage}
\begin{itemize}
\item ${\it exists}\ \tt t.$ : If the goal is $ex (x:T), P t$, $\tt t$ is a term of $T$. 
\end{itemize}

\subsubsection*{Implementation}
The tactic automatic generate the subgoal $P x$.
\begin{center}
\begin{minipage}{0.7\textwidth}
\begin{minted}{coq}
(* Current Goal *)                                                           
ex nat (fun (n:nat) => eq nat (S (S O)) (plus n n))

(* $\Downarrow$ exists S O $\Downarrow$ *)

(* SubGoal *)
eq nat (S (S O)) (plus (S O) (S O))
\end{minted}
\end{minipage}
\end{center}

The proof object built is
\begin{center}
\begin{minipage}{0.7\textwidth}
\begin{minted}{coq}
ex_intro nat (fun (n:nat) => eq nat (S (S O)) (plus n n)) (S O) (* SubGoal *)
\end{minted}
\end{minipage}
\end{center}

\subsection{\it Induction}

This tactic applies to any goal. 
The argument term must be of inductive type and the tactic {\it induction} generates subgoals, 
one for each possible form of term, i.e. one for each constructor of the inductive type.

\subsubsection*{Usage}
\begin{itemize}
\item ${\it induction}\ \tt t.$ : $\tt t$ is a term of some inductive type.
\end{itemize}

\subsubsection*{Implementation}

The tactic generates the predicate by the goal and automatic generates the subgoals for every constructor of the type.
The equivalence relations introduced by the constructors are also handled.

If the term is a hypothesis, induction will find the dependencies, and try to move them and replace the subterms to solve the dependencies.
And then erase the original hypothesis.

\begin{center}
\begin{minipage}{0.7\textwidth}
\begin{minted}{coq}
                                                                   
n : nat                                                            
(* Current Goal *)   
eq nat (plus n O) n                       

(* $\Downarrow$ induction n $\Downarrow$ *)

(* SubGoal 1 *)    
eq nat (plus O O) O

n0 : nat                     
e : eq nat (plus n0 O) n0    
(* SubGoal 2 *)              
eq nat (plus (S n0) O) (S n0)
\end{minted}
\end{minipage}
\end{center}

After {\it induction}, all we need to prove is the property holds for $O$ and for any $n$, if $P(n)$ holds,
then the two subgoals are generated and $n$ is replaced by the constructors.

The case above is viewed from user's perspective.
On the other hand, in the system we also need to construct the term for back substitution.
\begin{center}
\begin{minipage}{\textwidth}
\begin{minted}{coq}
n : nat                               
(* Current Goal*)                              
eq nat (plus n O) n                             

(* $\Downarrow$ induction n $\Downarrow$ *)   

(* The proof object *)
(fun (n:nat) =>   
    nat_rect (fun (n0:nat) => eq nat (plus n0 O) n0)
    (* SubGoal 1 *)
    (fun (n0:nat) (e:eq nat (plus n0 O) n0) => (* SubGoal 2 *))
    n)                                                      
\end{minted}
\end{minipage}
\end{center}

\subsection{\it Intro}

If the current goal is a dependent product $\tt \forall x:T,\ U$, \textit{intro} puts 
$\tt x:T$ in the context, and the new subgoal is $\tt U$.\par
If the current goal is a non-dependent product $\tt \forall \_:T,\ U$, \textit{intro} renames
$\tt \_$ into $\tt s$ not in $\tt T,U$ and context. Then put $\tt s:T$ in the context, 
and the new subgoal becomes $\tt U$.

\subsubsection*{Usage}
\begin{itemize}
\item ${\it intro}\ .$ : introduce the outermost argument of current goal and rename them automatically.
\item ${\it intro}\ a_1\ a_2\ \cdots\ a_n.$ : introduce $n$ outermost arguments of current goal and
try to rename them into $a_1,a_2,\cdots,a_n$.
\end{itemize}

\subsubsection*{Implementation}
Since the context automatically preserves the index, we
can safely move the arguments out into the context without worrying about the index.

If the argument is dependent in either the conclusion or some hypotheses of the goal,
the argument is replaced by the appropriate constructor form in each of the resulting subgoals
and induction hypotheses are added to the local context.

\subsection{\it Intros}

If the current goal is a dependent (or non-dependent) product with $m$ arguments, namely,
$\tt \forall x_1:T_1,\ \forall x_2:T_2,\ \cdots\ \forall x_m:T_m,\ U$ where $\tt U$ is not a product type.
Then \textit{intros} will put these $m$ arguments into the context and rename automatically if necessary.

\subsubsection*{Usage}
\begin{itemize}
\item ${\it intros}.$ : introduce all the argument of current goal and rename them automatically.
\end{itemize}

\subsubsection*{Implementation}
Keep calling {\it intro} until all the goal has no arguments.

\subsection{\it Left Right}
These tactics apply to a goal that is of the disjunction type. Then we can proof one of the two sides to solve the goal.

\subsubsection*{Usage}
\begin{itemize}
    \item ${\it left}$
    \item ${\it right}$
\end{itemize}

\subsubsection*{Implementation}
The disjunction type in our system is defined as follows:
\begin{center}
\begin{minipage}{\textwidth}
\begin{minted}{coq}
Inductive or (A:Type) (B:Type) : Type :=
| or_introl : A -> or A B
| or_intror : B -> or A B. 
\end{minted}
\end{minipage}
\end{center}

The tactic ${\it left}$ builds the proof object with the \mintinline{coq}|or_introl| constructor.
The tactic ${\it right}$ builds the proof object with the \mintinline{coq}|or_intror| constructor.
Here is an example:
\begin{center}
\begin{minipage}{\textwidth}
\begin{minted}{coq}
(* Current Goal *)
or (eq nat O O) (eq nat (S O) (S O))

(* $\Downarrow$ left $\Downarrow$ *)

(* The proof object *)
or_introl (eq nat O O) (eq nat (S O) (S O)) (* SubGoal 1 *)
\end{minted}
\end{minipage}
\end{center}

\subsection{\it Split}
These tactics apply to a goal that is of the conjunction type. Then we need to proof the both sides to solve the goal.

\subsubsection*{Usage}
\begin{itemize}
\item ${\it split}$.
\end{itemize}

\subsubsection*{Implementation}
The conjunction type in our system is defined as follows:
\begin{center}
\begin{minipage}{\textwidth}
\begin{minted}{coq}
Inductive and (A:Type) (B:Type) : Type :=
| conj : A -> B -> and A B.   
\end{minted}
\end{minipage}
\end{center}

The proof object is built with the \mintinline{coq}|conj| constructor.
Here is an example:
\begin{center}
\begin{minipage}{\textwidth}
\begin{minted}{coq}
(* Current Goal *)
and (eq nat O O) (eq nat (S O) (S O))

(* $\Downarrow$ split $\Downarrow$ *)

(* The proof object *)
conj (eq nat O O) (eq nat (S O) (S O)) (* SubGoal 1 *) (* SubGoal 2 *)
\end{minted}
\end{minipage}
\end{center}


\subsection{\it Reflexivity}
This tactic applies to a goal that has the form \mintinline{coq}|eq T t u|, it check that $t$ and $u$ are convertible and then solves the goal.

\subsubsection*{Usage}
\begin{itemize}
\item ${\it reflexivity}$
\end{itemize}

\subsubsection*{Implementation}
This tactic simply checks if the terms are convertible and build the proof object with \mintinline{coq}|eq_refl| constructor.

\begin{center}
\begin{minipage}{0.7\textwidth}
\begin{minted}{coq}
n : nat
(* Current Goal *)  
eq nat n (plus O n)   

(* reflexivity *)

(* The Proof Object *)
fun (n:nat) => eq_refl nat n
\end{minted}
\end{minipage}
\end{center}

\subsection{\it Rewrite}

\subsection{\it Simpl}
This tactic applies to any goal, it tries to reduce a term to somthing still readable instead of fully normalizing it. They perform a sort of strong noormalization with a key difference:
it unfold a constant if and only if it leads to a $\iota-reduction$, i.e. reducing a match or unfolding a fixpoint.


\subsubsection*{Usage}
\begin{itemize}
\item ${\it simpl}$
\item ${\it simpl}\ \rm in\ \tt H$ : $\tt H$ is a hypothesis.
\end{itemize}

\subsubsection*{Implementation}

The tactic first applies $\beta\iota-$reduction, then it expands constants and tries to reduce further using $\beta\iota-$reduction, but, when no $\iota$ rule is applied after unfolding
then $\iota-reductions$ are not applied. For instance trying to use $\it simpl$ on \mintinline{coq}|eq nat (plus n O) n| changes nothing.
\begin{center}
\begin{minipage}{0.7\textwidth}
\begin{minted}{coq}
n : nat                        (* simpl => *)    e : nat
(* Current Goal *)                               (* Current Goal *)
eq nat (plus n O) (plus O n)                     eq nat (plus n O) n
\end{minted}
\end{minipage}
\end{center}

The tactic can also be applied to the hypotheses, and the same reduction rules applies.
\begin{center}
\begin{minted}{coq}
n : nat                                                    n : nat                
e : eq nat (plus n O) (plus O n)    (* simpl in e => *)    e : eq nat (plus n O) n
(* Current Goal *)                                         (* Current Goal *)      
eq nat (plus n O) n                                        eq nat (plus n O) n         
\end{minted} 
\end{center}

The tactic would never change the current built proof object and won't modify the proof objects built after it.
It is transparent in the proof tree.

\subsection{\it Exact}

This tactic checks if the input term is actually of the goal's type. If so, the proof of the current goal is finished and the 
constructed proof object is exactly the input term.

\subsubsection*{Usage}
\begin{itemize}
\item ${\it exact}\ \tt t.$ : $\tt t$ is a term of the goal's type. 
\end{itemize}

\subsubsection*{Implementation}
It's easy to implement.Here is an example.
\begin{center}
\begin{minipage}{0.7\textwidth}
\begin{minted}{coq}
m : nat                                                      
(* Current Goal *)  (* exact eq_refl nat m => *)  (* No more goals *)
eq nat m m                                       
\end{minted}
\end{minipage}
\end{center}


\subsection{\it Symmetry}
This tactic applies to a goal that has the form \mintinline{coq}|eq T t u| and changes it into \mintinline{coq}|eq T u t|.

\subsubsection*{Usage}
\begin{itemize}
\item ${\it symmetry}$.
\end{itemize}

\subsubsection*{Implementation}
This tactic builds the proof object use the pre-defined theorem \mintinline{coq}|eq_sym|, here is an example for the proof object building.
\begin{center}
\begin{minipage}{\textwidth}
\begin{minted}{coq}
m : nat
n : nat
e : eq nat m n                    
(* Current Goal*)                              
eq nat n m                           

(* $\Downarrow$ symmetry $\Downarrow$ *)   

(* The proof object *)
fun (m:nat) (n:nat) (e:eq nat m n) =>   
    eq_sym nat m n (* SubGoal *)                                                
\end{minted}
\end{minipage}
\end{center}


\subsection{\it Unfold}
This tactic applies to any goal, the argument should denote a defined constant(i.e. not a hypothesis or a axiom).
The tactic applies the $\delta$ rule to each occurrence of the constant in the current goal and then replaces it with its $\beta\iota$-normal form.

\subsubsection*{Usage}
\begin{itemize}
\item ${\it unfold}\ \tt i.$ : $\tt i$ is an identifier. 
\item ${\it unfold}\ \tt i\ \rm in\ \tt H$ : $i$ is an identifier and $H$ is a hypothesis.
\end{itemize}

\subsubsection*{Implementation}
It finds the occurrences of the constant and applies the $\delta$ rule, the nameless index is automatically preserved.
